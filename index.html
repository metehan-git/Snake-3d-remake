<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Snake Game</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            font-family: 'Arial', sans-serif;
            overflow: hidden;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            color: white;
            font-size: 24px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        /* Level Progression UI */
        #levelUI {
            position: absolute;
            top: 20px;
            right: 80px;
            z-index: 100;
            color: white;
            text-align: right;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        #levelIndicator {
            font-size: 28px;
            font-weight: bold;
            color: #4ecdc4;
            margin-bottom: 10px;
        }

        #progressContainer {
            width: 200px;
            background: rgba(0,0,0,0.5);
            border-radius: 15px;
            padding: 8px;
            border: 2px solid #4ecdc4;
        }

        #progressBar {
            width: 100%;
            height: 12px;
            background: rgba(255,255,255,0.2);
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }

        #progressFill {
            height: 100%;
            background: linear-gradient(90deg, #4ecdc4, #44a08d);
            width: 0%;
            border-radius: 10px;
            transition: width 0.5s ease;
        }

        #progressText {
            font-size: 14px;
            margin-top: 5px;
            opacity: 0.9;
        }

        #levelTitle {
            font-size: 16px;
            margin-top: 5px;
            color: #f39c12;
            font-weight: bold;
        }

        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 200;
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 40px;
            border-radius: 15px;
            text-align: center;
            display: none;
            border: 3px solid #ff6b6b;
        }

        #startScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 200;
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 40px;
            border-radius: 15px;
            text-align: center;
            border: 3px solid #4ecdc4;
        }

        .button {
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
            border: none;
            color: white;
            padding: 15px 30px;
            font-size: 18px;
            border-radius: 8px;
            cursor: pointer;
            margin-top: 20px;
            transition: all 0.3s ease;
        }

        .button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(78, 205, 196, 0.4);
        }

        .restart-button {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
        }

        .restart-button:hover {
            box-shadow: 0 5px 15px rgba(255, 107, 107, 0.4);
        }

        #instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            z-index: 100;
            font-size: 14px;
            opacity: 0.8;
        }


        #notificationArea {
            position: absolute;
            top: 50px; /* Ekranın üst kısmına yakın */
            left: 50%; /* Yatayda ortalama */
            transform: translateX(-50%); /* Kendi genişliğinin yarısı kadar sola kaydırarak tam ortalama */
            z-index: 100;
            display: flex;
            flex-direction: row; /* Bildirimleri yan yana (sağa doğru) sırala */
            justify-content: center; /* Satır içindeki öğeleri yatayda ortala */
            gap: 20px; /* Bildirimler arası yatay boşluk */
        }

        .hit-notification {
            font-size: 60px; /* Font boyutunu çok büyüttük */
            font-weight: bold; /* Daha belirgin olması için kalın yapalım */
            text-shadow: 3px 3px 6px rgba(0,0,0,0.8); /* Gölgeyi artırdık */
            opacity: 1;
            transition: opacity 0.5s ease-in-out; /* Soluklaşma geçişi */
            pointer-events: none; /* Tıklanamaz yap */
        }
        .hit-notification.wall-hit {
            color: #3498db; /* Mavi */
        }

        .hit-notification.obstacle-hit {
            color: #e74c3c; /* Kırmızı */
        }

        .hit-edge {
            position: absolute;
            background-color: transparent; /* Başlangıçta şeffaf */
            z-index: 300;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease-out;
        }

        #hitTop {
            top: 0;
            left: 0;
            width: 100%;
            height: 10px; /* Kenar kalınlığı */
        }

        #hitBottom {
            bottom: 0;
            left: 0;
            width: 100%;
            height: 10px; /* Kenar kalınlığı */
        }

        #hitLeft {
            top: 0;
            left: 0;
            width: 10px; /* Kenar kalınlığı */
            height: 100%;
        }

        #hitRight {
            top: 0;
            right: 0;
            width: 10px; /* Kenar kalınlığı */
            height: 100%;
        }

        .hit-edge.light-hit {
            background-color: rgba(255, 100, 100, 0.5); /* Açık kırmızı tonu */
            opacity: 1;
        }

        .hit-edge.dark-hit {
            background-color: rgba(255, 0, 0, 0.7); /* Koyu kırmızı tonu */
            opacity: 1;
        }

        .hit-edge.reward-hit {
            background-color: rgba(255, 215, 0, 0.5); /* Altın sarısı tonu */
            opacity: 1;
        }

        /* Settings Button */
        #settingsButton {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
            border: none;
            border-radius: 50%;
            cursor: pointer;
            z-index: 150;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: white;
            box-shadow: 0 4px 15px rgba(78, 205, 196, 0.3);
            transition: all 0.3s ease;
        }

        #settingsButton:hover {
            transform: translateY(-2px) scale(1.1);
            box-shadow: 0 8px 25px rgba(78, 205, 196, 0.5);
        }

        /* Quality Settings Modal */
        #qualityModal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            display: none;
            align-items: center;
            justify-content: center;
        }

        #qualityModal.show {
            display: flex;
        }

        .modal-content {
            background: linear-gradient(135deg, #2c3e50, #34495e);
            padding: 40px;
            border-radius: 20px;
            max-width: 600px;
            width: 90%;
            text-align: center;
            color: white;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            border: 2px solid #4ecdc4;
        }

        .modal-title {
            font-size: 28px;
            margin-bottom: 30px;
            color: #4ecdc4;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        .quality-options {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }

        .quality-card {
            background: linear-gradient(135deg, #3498db, #2980b9);
            padding: 25px 15px;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 3px solid transparent;
            position: relative;
        }

        .quality-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(52, 152, 219, 0.4);
        }

        .quality-card.selected {
            border-color: #4ecdc4;
            background: linear-gradient(135deg, #4ecdc4, #44a08d);
        }

        .quality-card.low {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
        }

        .quality-card.low:hover {
            box-shadow: 0 10px 30px rgba(231, 76, 60, 0.4);
        }

        .quality-card.low.selected {
            border-color: #4ecdc4;
        }

        .quality-card.high {
            background: linear-gradient(135deg, #27ae60, #229954);
        }

        .quality-card.high:hover {
            box-shadow: 0 10px 30px rgba(39, 174, 96, 0.4);
        }

        .quality-card.high.selected {
            border-color: #4ecdc4;
        }

        .quality-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .quality-description {
            font-size: 12px;
            opacity: 0.9;
            line-height: 1.4;
        }

        .quality-specs {
            font-size: 10px;
            margin-top: 8px;
            opacity: 0.7;
        }

        .modal-buttons {
            margin-top: 30px;
            display: flex;
            gap: 15px;
            justify-content: center;
        }

        .modal-button {
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
            border: none;
            color: white;
            padding: 12px 25px;
            font-size: 16px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .modal-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(78, 205, 196, 0.4);
        }

        .modal-button.cancel {
            background: linear-gradient(45deg, #95a5a6, #7f8c8d);
        }

        .modal-button.cancel:hover {
            box-shadow: 0 5px 15px rgba(149, 165, 166, 0.4);
        }

        /* Achievement Notification */
        .achievement-notification {
            position: fixed;
            top: 50%;
            right: -400px;
            transform: translateY(-50%);
            background: linear-gradient(135deg, #f39c12, #e67e22);
            color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            z-index: 600;
            max-width: 300px;
            transition: right 0.5s ease;
        }

        .achievement-notification.show {
            right: 20px;
        }

        .achievement-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .achievement-description {
            font-size: 14px;
            opacity: 0.9;
        }

        /* Level Notification Bar */
        #levelNotificationBar {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            background: linear-gradient(135deg, rgba(78, 205, 196, 0.95), rgba(68, 160, 141, 0.95));
            color: white;
            padding: 15px 20px;
            z-index: 150;
            transform: translateY(100%);
            transition: transform 0.5s ease-in-out;
            backdrop-filter: blur(10px);
            border-top: 3px solid #4ecdc4;
            box-shadow: 0 -5px 20px rgba(0, 0, 0, 0.3);
        }

        #levelNotificationBar.show {
            transform: translateY(0);
        }

        .notification-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            max-width: 1200px;
            margin: 0 auto;
        }

        .notification-main {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .notification-icon {
            font-size: 32px;
            animation: celebrationPulse 2s ease-in-out infinite;
        }

        .notification-text {
            display: flex;
            flex-direction: column;
        }

        .notification-title {
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 2px;
        }

        .notification-details {
            font-size: 16px;
            opacity: 0.9;
            color: #f39c12;
            font-weight: bold;
        }

        .notification-next {
            text-align: right;
            opacity: 0.8;
        }

        .next-level-text {
            font-size: 16px;
            margin-bottom: 2px;
        }

        .next-target-text {
            font-size: 14px;
            color: #e8f8f5;
        }

        @keyframes celebrationPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        /* Responsive Design for Mobile */
        @media (max-width: 768px) {
            /* Settings button mobile positioning */
            #settingsButton {
                left: 50%;
                transform: translateX(-50%);
            }
            
            /* Level UI mobile repositioning */
            #levelUI {
                top: 20px;
                right: 20px;
                text-align: right;
            }
            
            /* Progress container mobile styling */
            #progressContainer {
                width: 160px;
            }
            
            /* Level title mobile styling */
            #levelTitle {
                font-size: 14px;
            }
            
            /* Achievement progress mobile styling */
            #achievementProgress {
                font-size: 11px !important;
            }
            
            /* Achievement notification mobile positioning */
            .achievement-notification {
                max-width: 250px;
            }
            
            /* Notification area mobile positioning - below score UI */
            #notificationArea {
                top: 110px;
                left: 20px;
                transform: none;
                flex-direction: column;
                align-items: flex-start;
                gap: 5px;
            }
            
            /* Mobile notification styling - more minimal */
            .hit-notification {
                font-size: 24px !important;
                text-shadow: 1px 1px 2px rgba(0,0,0,0.6);
                background: rgba(0,0,0,0.7);
                padding: 6px 10px;
                border-radius: 4px;
                border-left: 3px solid currentColor;
            }
            
            #levelNotificationBar {
                padding: 12px 15px;
            }
            
            .notification-content {
                flex-direction: column;
                gap: 10px;
                text-align: center;
            }
            
            .notification-main {
                justify-content: center;
            }
            
            .notification-icon {
                font-size: 28px;
            }
            
            .notification-title {
                font-size: 18px;
            }
            
            .notification-details {
                font-size: 14px;
            }
            
            .notification-next {
                text-align: center;
            }
            
            .next-level-text {
                font-size: 14px;
            }
            
            .next-target-text {
                font-size: 12px;
            }
        }
        
        /* Additional mobile breakpoints for smaller screens */
        @media (max-width: 480px) {
            /* Level UI for small mobile screens */
            #levelUI {
                top: 20px;
                right: 15px;
            }
            
            /* Progress container for small screens */
            #progressContainer {
                width: 140px;
            }
            
            /* Level title for small screens */
            #levelTitle {
                font-size: 13px;
            }
            
            /* Achievement progress for small screens */
            #achievementProgress {
                font-size: 10px !important;
            }
            
            /* Achievement notification for small screens */
            .achievement-notification {
                max-width: 220px;
            }
            
            /* Notification area for small screens */
            #notificationArea {
                top: 105px;
                left: 15px;
            }
            
            /* Even more minimal notifications on small screens */
            .hit-notification {
                font-size: 20px !important;
                padding: 5px 8px;
            }
        }
        
        /* Very small mobile screens */
        @media (max-width: 360px) {
            /* Level UI for very small screens */
            #levelUI {
                top: 20px;
                right: 10px;
            }
            
            /* Progress container for very small screens */
            #progressContainer {
                width: 120px;
            }
            
            /* Level title for very small screens */
            #levelTitle {
                font-size: 12px;
            }
            
            /* Achievement progress for very small screens */
            #achievementProgress {
                font-size: 9px !important;
            }
            
            /* Notification area for very small screens */
            #notificationArea {
                top: 100px;
                left: 10px;
            }
            
            /* Ultra minimal notifications on very small screens */
            .hit-notification {
                font-size: 18px !important;
                padding: 4px 7px;
            }
        }

    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="ui">
            <div>Skor: <span id="score">0</span></div>
            <div>Uzunluk: <span id="length">5</span></div>
            <div style="font-size: 12px; opacity: 0.8; margin-top: 5px;">Kalite: <span id="qualityIndicator">Orta</span></div>
        </div>

        <!-- Level Progression UI -->
        <div id="levelUI">
            <div id="levelIndicator">Level 1</div>
            <div id="progressContainer">
                <div id="progressBar">
                    <div id="progressFill"></div>
                </div>
                <div id="progressText">0 / 200</div>
            </div>
            <div id="levelTitle">Başlangıç Seviyesi</div>
            <div id="achievementProgress" style="font-size: 12px; margin-top: 5px; opacity: 0.8;">Başarımlar: 0/9</div>
        </div>

        <div id="notificationArea">
            <!-- Bildirimler buraya eklenecek -->
        </div>

        <div id="startScreen">
            <h1 style="color: #4ecdc4; margin-bottom: 30px;">🐍 3D YILAN OYUNU</h1>
            <p>Elmaları topla ve büyü!</p>
            <p>Duvarlara ve kendine çarpma!</p>
            <button class="button" onclick="startGame()">OYUNU BAŞLAT</button>
        </div>

        <div id="gameOver">
            <h2 style="color: #ff6b6b;">OYUN BİTTİ!</h2>
            <p>Final Skorun: <span id="finalScore">0</span></p>
            <button class="button restart-button" onclick="restartGame()">TEKRAR BAŞLA</button>
        </div>

        <div id="instructions">
            <div>Kontroller: WASD veya Ok Tuşları</div>
            <div>🍏 Yeşil Elma: +10 puan | 🍏 Altın Elma: +50 puan | 🍎 Yakut Elma: +25 puan | 🟢 Zümrüt: +35 puan</div>
            <div>🏆 Altın Ödül: +100 puan | ☠️ Kırmızı Küp: Ölüm</div>
        </div>

        <!-- Ekran kenarı efektleri için yeni divler -->
        <div id="hitTop" class="hit-edge"></div>
        <div id="hitBottom" class="hit-edge"></div>
        <div id="hitLeft" class="hit-edge"></div>
        <div id="hitRight" class="hit-edge"></div>

        <!-- Settings Button -->
        <button id="settingsButton" title="Kalite Ayarları">
            ⚙️
        </button>

        <!-- Achievement Notification -->
        <div id="achievementNotification" class="achievement-notification">
            <div class="achievement-title" id="achievementTitle">Başarım Kazanıldı!</div>
            <div class="achievement-description" id="achievementDescription">İlk levelı tamamladın!</div>
        </div>

        <!-- Level Notification Bar -->
        <div id="levelNotificationBar">
            <div class="notification-content">
                <div class="notification-main">
                    <div class="notification-icon">🎉</div>
                    <div class="notification-text">
                        <div class="notification-title">Level <span id="notificationLevel">1</span> Tamamlandı!</div>
                        <div class="notification-details">
                            Bonus: +<span id="notificationBonus">50</span> puan
                        </div>
                    </div>
                </div>
                <div class="notification-next">
                    <div class="next-level-text">Sıradaki Level: <span id="notificationNextLevel">2</span></div>
                    <div class="next-target-text">Hedef: <span id="notificationNextTarget">500</span> puan</div>
                </div>
            </div>
        </div>

        <!-- Quality Settings Modal -->
        <div id="qualityModal">
            <div class="modal-content">
                <h2 class="modal-title">🎮 Görüntü Kalitesi Ayarları</h2>
                
                <div class="quality-options">
                    <div class="quality-card low" data-quality="low">
                        <div class="quality-title">📉 Düşük Kalite</div>
                        <div class="quality-description">
                            Performans odaklı<br>
                            Daha hızlı çalışır
                        </div>
                        <div class="quality-specs">
                            • Gölgeler kapalı<br>
                            • Temel efektler<br>
                            • 30 FPS hedef
                        </div>
                    </div>
                    
                    <div class="quality-card medium selected" data-quality="medium">
                        <div class="quality-title">⚙️ Orta Kalite</div>
                        <div class="quality-description">
                            Dengeli deneyim<br>
                            Varsayılan ayar
                        </div>
                        <div class="quality-specs">
                            • Gölgeler açık<br>
                            • Standart efektler<br>
                            • 60 FPS hedef
                        </div>
                    </div>
                    
                    <div class="quality-card high" data-quality="high">
                        <div class="quality-title">🎆 Yüksek Kalite</div>
                        <div class="quality-description">
                            Görsel mükemmellik<br>
                            En iyi grafik
                        </div>
                        <div class="quality-specs">
                            • Gelişmiş gölgeler<br>
                            • Yüksek efektler<br>
                            • 120+ FPS uyumlu
                        </div>
                    </div>
                </div>
                
                <div class="modal-buttons">
                    <button class="modal-button" id="applyQuality">Uygula</button>
                    <button class="modal-button cancel" id="cancelQuality">İptal</button>
                </div>
            </div>
        </div>

    </div>

    <script>
        // Quality Settings Variables
        let currentQuality = 'medium';
        let qualitySettings = {
            low: {
                shadows: false,
                antialias: false,
                targetFPS: 30,
                shadowMapSize: 512,
                fogNear: 30,
                fogFar: 100,
                particleCount: 0.5,
                materialQuality: 'basic',
                lightIntensity: 0.8,
                animationSpeed: 0.5
            },
            medium: {
                shadows: true,
                antialias: true,
                targetFPS: 60,
                shadowMapSize: 1024,
                fogNear: 50,
                fogFar: 200,
                particleCount: 1.0,
                materialQuality: 'standard',
                lightIntensity: 1.0,
                animationSpeed: 1.0
            },
            high: {
                shadows: true,
                antialias: true,
                targetFPS: 120,
                shadowMapSize: 2048,
                fogNear: 75,
                fogFar: 300,
                particleCount: 1.75,
                materialQuality: 'enhanced',
                lightIntensity: 1.2,
                animationSpeed: 1.5
            }
        };

        let selectedQuality = 'medium';

        // Level Progression System
        class LevelManager {
            constructor() {
                this.currentLevel = 1;
                this.levelProgress = 0;
                this.isLevelComplete = false;
                this.streakCount = 0;
                this.scoreMultiplier = 1.0;
                this.perfectLevel = true; // No collisions this level
                this.levelStartTime = Date.now();
                
                // Level configuration
                this.levelConfig = {
                    1: { 
                        target: 200, 
                        speed: 120, 
                        obstacles: 2, 
                        walls: 4, 
                        title: "Başlangıç Seviyesi", 
                        theme: "Forest",
                        specialFoods: [
                            { type: 'goldenApple', count: 2 }
                        ]
                    },
                    2: { 
                        target: 500, 
                        speed: 110, 
                        obstacles: 3, 
                        walls: 6, 
                        title: "Hızlanan Tempo", 
                        theme: "Desert",
                        specialFoods: [
                            { type: 'rubyApple', count: 1 },
                            { type: 'goldenApple', count: 1 }
                        ]
                    },
                    3: { 
                        target: 900, 
                        speed: 100, 
                        obstacles: 4, 
                        walls: 8, 
                        title: "Çöl Kanyonu", 
                        theme: "Canyon",
                        specialFoods: [
                            { type: 'emeraldFruit', count: 1 },
                            { type: 'goldenApple', count: 1 }
                        ]
                    },
                    4: { 
                        target: 1400, 
                        speed: 90, 
                        obstacles: 5, 
                        walls: 10, 
                        title: "Dağ Geçidi", 
                        theme: "Mountain",
                        specialFoods: [
                            { type: 'rubyApple', count: 1 },
                            { type: 'emeraldFruit', count: 1 },
                            { type: 'goldenApple', count: 1 }
                        ]
                    },
                    5: { 
                        target: 2000, 
                        speed: 80, 
                        obstacles: 6, 
                        walls: 12, 
                        title: "Buzul Vadisi", 
                        theme: "Ice",
                        specialFoods: [
                            { type: 'rubyApple', count: 1 },
                            { type: 'emeraldFruit', count: 2 },
                            { type: 'goldenApple', count: 2 }
                        ]
                    },
                };
                
                // Achievement system
                this.achievements = {
                    firstSteps: { unlocked: false, name: "İlk Adımlar", desc: "Level 1'i tamamla", reward: "hız bonus" },
                    snakeMaster: { unlocked: false, name: "Yılan Ustası", desc: "Level 5'e ulaş", reward: "çarpma direnci" },
                    perfectGame: { unlocked: false, name: "Mükemmel Oyun", desc: "Hiç çarpmadan level tamamla", reward: "2x puan çarpanı" },
                    speedDemon: { unlocked: false, name: "Hız Şeytanı", desc: "Level'ı 60 saniyede tamamla", reward: "zaman bonusu" },
                    marathonRunner: { unlocked: false, name: "Maraton Koşucusu", desc: "Level 10'a ulaş", reward: "sonsuz mod" },
                    comboMaster: { unlocked: false, name: "Kombo Ustası", desc: "15x kombo yap", reward: "kombo süresi uzatılması" },
                    treasureHunter: { unlocked: false, name: "Hazine Avcısı", desc: "10 altın ödül topla", reward: "ödül değeri artışı" },
                    survivor: { unlocked: false, name: "Hayatta Kalan", desc: "100 engelden kaç", reward: "engel görünürlüğü" },
                    levelExplorer: { unlocked: false, name: "Seviye Kaşifi", desc: "Tüm seviyeleri keşfet", reward: "gizli mod" }
                };
                
                this.loadProgress();
            }
            
            initializeDefaultStats() {
                this.statistics = {
                    totalPlayTime: 0,
                    levelsCompleted: 0,
                    totalScore: 0,
                    perfectLevels: 0,
                    fastestLevelTime: Infinity,
                    gamesPlayed: 1
                };
            }
            
            getTotalPlayTime() {
                return (this.statistics?.totalPlayTime || 0) + (Date.now() - this.levelStartTime);
            }
            
            getTotalScore() {
                return (this.statistics?.totalScore || 0) + score;
            }
            
            getPerfectLevelsCount() {
                return (this.statistics?.perfectLevels || 0) + (this.perfectLevel ? 1 : 0);
            }
            
            getFastestLevelTime() {
                const currentTime = (Date.now() - this.levelStartTime) / 1000;
                return Math.min(this.statistics?.fastestLevelTime || Infinity, currentTime);
            }
            
            getGamesPlayed() {
                return this.statistics?.gamesPlayed || 0;
            }
            
            saveLevelStats() {
                const levelStats = JSON.parse(localStorage.getItem('snake_level_stats') || '{}');
                const currentTime = (Date.now() - this.levelStartTime) / 1000;
                
                if (!levelStats[this.currentLevel]) {
                    levelStats[this.currentLevel] = {
                        attempts: 0,
                        completions: 0,
                        bestTime: Infinity,
                        totalScore: 0
                    };
                }
                
                levelStats[this.currentLevel].attempts++;
                if (this.isLevelComplete) {
                    levelStats[this.currentLevel].completions++;
                    levelStats[this.currentLevel].bestTime = Math.min(levelStats[this.currentLevel].bestTime, currentTime);
                }
                levelStats[this.currentLevel].totalScore += score;
                
                localStorage.setItem('snake_level_stats', JSON.stringify(levelStats));
            }
            
            loadLevelStats() {
                this.levelStats = JSON.parse(localStorage.getItem('snake_level_stats') || '{}');
            }
            
            getPlayerStatistics() {
                return {
                    ...this.statistics,
                    currentLevel: this.currentLevel,
                    achievements: this.achievements,
                    levelStats: this.levelStats
                };
            }
            
            checkTreasureHunter() {
                const treasureCount = this.statistics?.treasuresCollected || 0;
                if (treasureCount >= 10 && !this.achievements.treasureHunter.unlocked) {
                    this.achievements.treasureHunter.unlocked = true;
                    setTimeout(() => this.showAchievement(this.achievements.treasureHunter), 1000);
                }
            }
            
            checkLevelExplorer() {
                const levelsCompleted = this.statistics?.levelsCompleted || 0;
                if (levelsCompleted >= 5 && !this.achievements.levelExplorer.unlocked) {
                    this.achievements.levelExplorer.unlocked = true;
                    setTimeout(() => this.showAchievement(this.achievements.levelExplorer), 1500);
                }
            }
            
            onTreasureCollected() {
                if (!this.statistics.treasuresCollected) {
                    this.statistics.treasuresCollected = 0;
                }
                this.statistics.treasuresCollected++;
                this.checkTreasureHunter();
            }
            
            getAchievementProgress() {
                const total = Object.keys(this.achievements).length;
                const unlocked = Object.values(this.achievements).filter(a => a.unlocked).length;
                return { unlocked, total, percentage: Math.round((unlocked / total) * 100) };
            }
            
            getCurrentConfig() {
                // For levels beyond 5, calculate progressive difficulty
                if (this.currentLevel <= 5) {
                    return this.levelConfig[this.currentLevel];
                } else {
                    const baseLevel = 5;
                    const levelDiff = this.currentLevel - baseLevel;
                    return {
                        target: 2000 + (levelDiff * 700),
                        speed: Math.max(50, 80 - (levelDiff * 10)), // Faster progression, minimum 50ms
                        obstacles: Math.min(12, 6 + levelDiff),
                        walls: Math.min(20, 12 + (levelDiff * 2)),
                        title: `Level ${this.currentLevel}`,
                        theme: "Advanced"
                    };
                }
            }
            
            checkLevelProgress(currentScore) {
                const config = this.getCurrentConfig();
                this.levelProgress = Math.min(100, (currentScore / config.target) * 100);
                
                if (currentScore >= config.target && !this.isLevelComplete) {
                    this.completeLevel(currentScore);
                }
                
                return this.levelProgress;
            }
            
            completeLevel(finalScore) {
                this.isLevelComplete = true;
                const levelTime = (Date.now() - this.levelStartTime) / 1000;
                
                // Calculate bonuses
                let levelBonus = 50 * this.currentLevel;
                let perfectBonus = this.perfectLevel ? 100 : 0;
                let speedBonus = levelTime < 60 ? 100 : 0;
                
                const totalBonus = levelBonus + perfectBonus + speedBonus;
                
                // Play level complete sound
                playLevelCompleteSound();
                
                // Check achievements
                this.checkAchievements(levelTime);
                
                // Show bottom notification
                this.showBottomLevelNotification(totalBonus);
                
                // Apply bonuses to score
                score += totalBonus;
                
                // Save progress
                this.saveProgress();
                
                return totalBonus;
            }
            
            advanceToNextLevel() {
                this.currentLevel++;
                this.levelProgress = 0;
                this.isLevelComplete = false;
                this.streakCount = 0;
                this.scoreMultiplier = 1.0;
                this.perfectLevel = true;
                this.levelStartTime = Date.now();
                
                // Play level start sound
                playLevelStartSound();
                
                // Apply new level speed
                this.applyLevelSpeed();
                
                // Apply new difficulty (obstacles and walls)
                this.applyDifficulty();
                
                // Update UI
                this.updateLevelUI();
                
                // Save progress
                this.saveProgress();
            }
            
            applyDifficulty() {
                const config = this.getCurrentConfig();
                
                // Update game speed ONLY when explicitly called for level changes
                // This prevents speed changes during food eating
                
                // Create new obstacles and walls based on level
                this.regenerateLevel(config);
            }
            
            applyLevelSpeed() {
                const config = this.getCurrentConfig();
                // Update game speed - separate function for level transitions only
                gameSpeed = config.speed;
            }
            
            regenerateObstaclesOnly() {
                // Only regenerate obstacles without changing speed or walls
                const config = this.getCurrentConfig();
                
                // Clear existing obstacles only
                obstacles.forEach(obstacle => scene.remove(obstacle));
                obstacles.length = 0;
                
                // Create new obstacles (all static now)
                this.createObstaclesForLevel(config.obstacles);
            }
            
            regenerateLevel(config) {
                // Clear existing obstacles and walls
                obstacles.forEach(obstacle => scene.remove(obstacle));
                walls.forEach(wall => scene.remove(wall));
                obstacles.length = 0;
                walls.length = 0;
                
                // Create new walls
                this.createWallsForLevel(config.walls);
                
                // Create new obstacles (all static now)
                this.createObstaclesForLevel(config.obstacles);
            }
            
            createWallsForLevel(count) {
                const wallMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x3498db,
                    shininess: 100
                });
                
                for (let i = 0; i < count; i++) {
                    const wallGeometry = new THREE.BoxGeometry(GRID_SIZE, GRID_SIZE * 2, GRID_SIZE);
                    const wall = new THREE.Mesh(wallGeometry, wallMaterial);
                    
                    let pos;
                    do {
                        pos = getRandomPosition();
                    } while (isPositionOccupied(pos.x, pos.z));
                    
                    wall.position.set(pos.x, 1, pos.z);
                    wall.castShadow = true;
                    wall.receiveShadow = true;
                    walls.push(wall);
                    scene.add(wall);
                }
            }
            
            createObstaclesForLevel(count) {
                const obstacleMaterial = new THREE.MeshPhongMaterial({
                    color: 0xe74c3c,
                    shininess: 50
                });
                
                const purpleObstacleMaterial = new THREE.MeshPhongMaterial({
                    color: 0x8e44ad, // Purple for special obstacles
                    shininess: 100,
                    emissive: 0x2e1e3d
                });
                
                const obstacleGeometry = new THREE.BoxGeometry(GRID_SIZE, GRID_SIZE * 1.5, GRID_SIZE);
                const purpleObstacleGeometry = new THREE.CylinderGeometry(GRID_SIZE * 0.6, GRID_SIZE * 0.6, GRID_SIZE * 1.8, 8); // Cylinder shape for purple obstacles
                
                for (let i = 0; i < count; i++) {
                    const isPurple = this.currentLevel >= 2 && i < Math.floor(count / 2); // Half obstacles are purple starting from level 2
                    const material = isPurple ? purpleObstacleMaterial : obstacleMaterial;
                    const geometry = isPurple ? purpleObstacleGeometry : obstacleGeometry;
                    const obstacle = new THREE.Mesh(geometry, material);
                    
                    let pos;
                    do {
                        pos = getRandomPosition();
                    } while (isPositionOccupied(pos.x, pos.z));
                    
                    obstacle.position.set(pos.x, 0.75, pos.z);
                    obstacle.castShadow = true;
                    
                    // No more movement properties - all obstacles are now static
                    
                    obstacles.push(obstacle);
                    scene.add(obstacle);
                }
            }
            
            onCollision(type) {
                this.perfectLevel = false;
                if (type === 'wall') {
                    this.streakCount = 0;
                    this.scoreMultiplier = 1.0;
                } else if (type === 'obstacle') {
                    this.streakCount = 0;
                    this.scoreMultiplier = 1.0;
                }
            }
            
            onFoodEaten() {
                this.streakCount++;
                
                // Update multiplier based on streak
                const oldMultiplier = this.scoreMultiplier;
                if (this.streakCount >= 15) {
                    this.scoreMultiplier = 2.0;
                } else if (this.streakCount >= 10) {
                    this.scoreMultiplier = 1.5;
                } else if (this.streakCount >= 5) {
                    this.scoreMultiplier = 1.2;
                } else {
                    this.scoreMultiplier = 1.0;
                }
                
                // Play streak sound if multiplier changed
                if (this.scoreMultiplier > oldMultiplier) {
                    playStreakSound(this.scoreMultiplier);
                    this.showStreakNotification();
                }
                
                // Play progress milestone sound every 25% progress
                const progress = this.checkLevelProgress(score);
                if (progress >= 25 && progress < 30) {
                    playProgressMilestoneSound();
                } else if (progress >= 50 && progress < 55) {
                    playProgressMilestoneSound();
                } else if (progress >= 75 && progress < 80) {
                    playProgressMilestoneSound();
                }
            }
            
            updateLevelUI() {
                const config = this.getCurrentConfig();
                
                document.getElementById('levelIndicator').textContent = `Level ${this.currentLevel}`;
                document.getElementById('levelTitle').textContent = config.title;
                
                const progressFill = document.getElementById('progressFill');
                const progressText = document.getElementById('progressText');
                
                // Smooth progress bar animation
                const targetWidth = `${this.levelProgress}%`;
                progressFill.style.setProperty('--progress-width', targetWidth);
                progressFill.style.width = targetWidth;
                
                // Add visual feedback for milestones
                if (this.levelProgress >= 25 && this.levelProgress < 30) {
                    progressFill.style.boxShadow = '0 0 10px rgba(78, 205, 196, 0.6)';
                } else if (this.levelProgress >= 50 && this.levelProgress < 55) {
                    progressFill.style.boxShadow = '0 0 15px rgba(78, 205, 196, 0.8)';
                } else if (this.levelProgress >= 75 && this.levelProgress < 80) {
                    progressFill.style.boxShadow = '0 0 20px rgba(78, 205, 196, 1.0)';
                } else if (this.levelProgress >= 95) {
                    progressFill.style.boxShadow = '0 0 25px rgba(78, 205, 196, 1.0), 0 0 50px rgba(78, 205, 196, 0.5)';
                } else {
                    progressFill.style.boxShadow = 'none';
                }
                
                progressText.textContent = `${score} / ${config.target}`;
                
                // Add score multiplier display if active
                if (this.scoreMultiplier > 1.0) {
                    progressText.innerHTML = `${score} / ${config.target} <span style="color: #f39c12; font-weight: bold;">(${this.scoreMultiplier}x)</span>`;
                }
                
                // Update achievement progress
                const achievementProgress = this.getAchievementProgress();
                const achievementElement = document.getElementById('achievementProgress');
                if (achievementElement) {
                    achievementElement.textContent = `Başarımlar: ${achievementProgress.unlocked}/${achievementProgress.total} (${achievementProgress.percentage}%)`;
                }
            }
            
            showBottomLevelNotification(bonus) {
                const notification = document.getElementById('levelNotificationBar');
                const nextLevel = this.currentLevel + 1;
                const nextConfig = this.levelConfig[nextLevel] || { target: 2000 + ((nextLevel - 5) * 700) };
                
                // Update notification content
                document.getElementById('notificationLevel').textContent = this.currentLevel;
                document.getElementById('notificationBonus').textContent = bonus;
                document.getElementById('notificationNextLevel').textContent = nextLevel;
                document.getElementById('notificationNextTarget').textContent = nextConfig.target;
                
                // Show notification with animation
                notification.classList.add('show');
                
                // Continue game without pause - immediately advance to next level
                this.advanceToNextLevel();
                
                // Auto-hide after 3 seconds
                setTimeout(() => {
                    notification.classList.remove('show');
                }, 3000);
            }
            
            checkAchievements(levelTime) {
                let newAchievements = [];
                
                // First Steps - Complete Level 1
                if (this.currentLevel === 1 && !this.achievements.firstSteps.unlocked) {
                    this.achievements.firstSteps.unlocked = true;
                    newAchievements.push(this.achievements.firstSteps);
                }
                
                // Snake Master - Reach Level 5
                if (this.currentLevel === 5 && !this.achievements.snakeMaster.unlocked) {
                    this.achievements.snakeMaster.unlocked = true;
                    newAchievements.push(this.achievements.snakeMaster);
                }
                
                // Perfect Game - Complete level without collisions
                if (this.perfectLevel && !this.achievements.perfectGame.unlocked) {
                    this.achievements.perfectGame.unlocked = true;
                    newAchievements.push(this.achievements.perfectGame);
                }
                
                // Speed Demon - Complete level in under 60s
                if (levelTime < 60 && !this.achievements.speedDemon.unlocked) {
                    this.achievements.speedDemon.unlocked = true;
                    newAchievements.push(this.achievements.speedDemon);
                }
                
                // Marathon Runner - Reach Level 10
                if (this.currentLevel === 10 && !this.achievements.marathonRunner.unlocked) {
                    this.achievements.marathonRunner.unlocked = true;
                    newAchievements.push(this.achievements.marathonRunner);
                }
                
                // Combo Master - Achieve 15x multiplier
                if (this.scoreMultiplier >= 2.0 && !this.achievements.comboMaster.unlocked) {
                    this.achievements.comboMaster.unlocked = true;
                    newAchievements.push(this.achievements.comboMaster);
                }
                
                // Check treasure hunter achievement
                this.checkTreasureHunter();
                
                // Level Explorer - Complete 5 different levels
                this.checkLevelExplorer();
                
                // Show achievement notifications
                newAchievements.forEach((achievement, index) => {
                    setTimeout(() => {
                        this.showAchievement(achievement);
                    }, index * 2000);
                });
            }
            
            showAchievement(achievement) {
                const notification = document.getElementById('achievementNotification');
                document.getElementById('achievementTitle').textContent = achievement.name;
                document.getElementById('achievementDescription').textContent = achievement.desc;
                
                notification.classList.add('show');
                
                // Hide after 4 seconds
                setTimeout(() => {
                    notification.classList.remove('show');
                }, 4000);
                
                // Play achievement sound
                playAchievementSound();
            }
            
            showStreakNotification() {
                const notificationArea = document.getElementById('notificationArea');
                const notification = document.createElement('div');
                notification.classList.add('hit-notification');
                notification.style.color = '#f39c12';
                notification.style.fontSize = '48px';
                notification.textContent = `${this.scoreMultiplier}x COMBO!`;
                
                notificationArea.appendChild(notification);
                
                // Auto-remove after animation
                setTimeout(() => {
                    notification.style.opacity = '0';
                    setTimeout(() => {
                        if (notification.parentNode) {
                            notificationArea.removeChild(notification);
                        }
                    }, 500);
                }, 2000);
            }
            
            saveProgress() {
                const saveData = {
                    currentLevel: this.currentLevel,
                    achievements: this.achievements,
                    highScore: Math.max(score, parseInt(localStorage.getItem('snake_high_score') || '0')),
                    totalPlayTime: this.getTotalPlayTime(),
                    levelsCompleted: this.currentLevel - 1,
                    totalScore: this.getTotalScore(),
                    perfectLevels: this.getPerfectLevelsCount(),
                    fastestLevelTime: this.getFastestLevelTime(),
                    gameVersion: '2.0',
                    lastPlayed: Date.now()
                };
                
                localStorage.setItem('snake_game_progress', JSON.stringify(saveData));
                if (saveData.highScore > parseInt(localStorage.getItem('snake_high_score') || '0')) {
                    localStorage.setItem('snake_high_score', saveData.highScore.toString());
                }
                
                // Save level-specific statistics
                this.saveLevelStats();
            }
            
            loadProgress() {
                const saved = localStorage.getItem('snake_game_progress');
                if (saved) {
                    try {
                        const data = JSON.parse(saved);
                        // For now, always start from level 1 but keep achievements and stats
                        this.currentLevel = 1; // Always start from level 1
                        this.achievements = { ...this.achievements, ...data.achievements };
                        
                        // Load statistics if available
                        this.statistics = {
                            totalPlayTime: data.totalPlayTime || 0,
                            levelsCompleted: data.levelsCompleted || 0,
                            totalScore: data.totalScore || 0,
                            perfectLevels: data.perfectLevels || 0,
                            fastestLevelTime: data.fastestLevelTime || Infinity,
                            gamesPlayed: this.getGamesPlayed() + 1
                        };
                        
                        this.loadLevelStats();
                    } catch (e) {
                        console.log('Failed to load progress:', e);
                        this.initializeDefaultStats();
                    }
                } else {
                    this.initializeDefaultStats();
                }
            }
            
            resetLevel() {
                this.currentLevel = 1;
                this.levelProgress = 0;
                this.isLevelComplete = false;
                this.streakCount = 0;
                this.scoreMultiplier = 1.0;
                this.perfectLevel = true;
                this.levelStartTime = Date.now();
                
                // Apply level 1 speed
                this.applyLevelSpeed();
                this.applyDifficulty();
                this.updateLevelUI();
            }
        }
        
        // Initialize level manager
        let levelManager = null;

        let scene, camera, renderer;
        let snake = [];
        let food = [];
        let specialFoods = []; // Array to hold special foods (golden apples, etc.)
        let walls = [];
        let obstacles = [];
        let specialReward;
        let direction = 'right';
        let nextDirection = 'right';
        let gameRunning = false;
        let score = 80; // Start with 80 points as requested
        let gameSpeed = 120; // Faster default speed for better responsiveness
        let lastUpdateTime = 0;

        const GRID_SIZE = 2;
        const BOARD_SIZE = 30;
        const BOARD_OFFSET = BOARD_SIZE * GRID_SIZE / 2;

        // Special Food Types Configuration
        const SPECIAL_FOOD_TYPES = {
            goldenApple: {
                name: 'Golden Apple',
                color: 0xf39c12, // Orange/Golden
                points: 50,
                segments: 3, // How many segments to add to snake
                emissive: 0x331a00,
                scale: 1.3
            },
            rubyApple: {
                name: 'Ruby Apple',
                color: 0xe74c3c, // Red
                points: 25,
                segments: 2,
                emissive: 0x330000,
                scale: 1.1
            },
            emeraldFruit: {
                name: 'Emerald Fruit',
                color: 0x1abc9c, // Cyan
                points: 35,
                segments: 2,
                emissive: 0x003324,
                scale: 1.2
            }
        };

        // Ses efektleri (Web Audio API ile)
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();

        function playSound(frequency, duration, type = 'sine') {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            oscillator.frequency.value = frequency;
            oscillator.type = type;

            gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);

            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration);
        }
        
        // Enhanced audio system for level progression
        function playLevelCompleteSound() {
            // Victory melody - ascending notes
            const notes = [523.25, 659.25, 783.99, 1046.50]; // C5, E5, G5, C6
            notes.forEach((freq, index) => {
                setTimeout(() => {
                    playSound(freq, 0.3, 'triangle');
                }, index * 150);
            });
        }
        
        function playLevelStartSound() {
            // Heroic fanfare
            playSound(440, 0.2, 'square'); // A4
            setTimeout(() => playSound(554.37, 0.2, 'square'), 100); // C#5
            setTimeout(() => playSound(659.25, 0.4, 'square'), 200); // E5
        }
        
        function playAchievementSound() {
            // Special achievement chime
            playSound(1000, 0.5, 'triangle');
            setTimeout(() => playSound(1200, 0.3, 'triangle'), 200);
            setTimeout(() => playSound(1500, 0.4, 'triangle'), 400);
        }
        
        function playProgressMilestoneSound() {
            // Progress milestone chime
            playSound(800, 0.2, 'sine');
            setTimeout(() => playSound(1000, 0.2, 'sine'), 150);
        }
        
        function playStreakSound(multiplier) {
            // Streak multiplier sound - higher pitch for higher multipliers
            const baseFreq = 600;
            const freq = baseFreq * multiplier;
            playSound(freq, 0.3, 'sawtooth');
        }

        // Quality Settings Functions
        function loadQualitySettings() {
            const saved = localStorage.getItem('snake_game_quality');
            if (saved && qualitySettings[saved]) {
                currentQuality = saved;
                selectedQuality = saved;
            }
            updateQualitySelection();
        }

        function saveQualitySettings() {
            localStorage.setItem('snake_game_quality', currentQuality);
        }

        function updateQualitySelection() {
            const cards = document.querySelectorAll('.quality-card');
            cards.forEach(card => {
                card.classList.remove('selected');
                if (card.dataset.quality === selectedQuality) {
                    card.classList.add('selected');
                }
            });
        }

        function applyQualitySettings(quality) {
            const settings = qualitySettings[quality];
            if (!settings) return;

            // Initialize or update fog
            if (!scene.fog) {
                scene.fog = new THREE.Fog(0x1e3c72, settings.fogNear, settings.fogFar);
            } else {
                scene.fog.near = settings.fogNear;
                scene.fog.far = settings.fogFar;
            }

            // Update renderer settings if renderer exists
            if (renderer) {
                renderer.shadowMap.enabled = settings.shadows;
                renderer.shadowMap.type = settings.shadows ? THREE.PCFSoftShadowMap : THREE.BasicShadowMap;
            }

            // Update lighting based on quality
            scene.traverse((object) => {
                if (object.type === 'DirectionalLight') {
                    object.intensity = settings.lightIntensity;
                    if (object.shadow && settings.shadows) {
                        object.castShadow = true;
                        object.shadow.mapSize.width = settings.shadowMapSize;
                        object.shadow.mapSize.height = settings.shadowMapSize;
                        object.shadow.map?.dispose();
                        object.shadow.map = null;
                    } else {
                        object.castShadow = false;
                    }
                } else if (object.type === 'PointLight') {
                    object.intensity = settings.lightIntensity;
                } else if (object.type === 'AmbientLight') {
                    object.intensity = 0.6 * settings.lightIntensity;
                }
            });

            // Update game speed based on target FPS - but preserve level-based speed scaling
            // Only modify speed if no level manager exists or for initial setup
            if (!levelManager) {
                gameSpeed = Math.max(80, Math.floor(2000 / settings.targetFPS)); // Faster baseline calculation
            }

            // Store animation speed multiplier for use in updateAnimations
            window.animationSpeedMultiplier = settings.animationSpeed;

            // Update global quality flag
            currentQuality = quality;
            
            // Update UI to show new quality
            if (typeof updateUI === 'function') {
                updateUI();
            }
            
            console.log(`Quality applied: ${quality}`, settings);
        }

        function openQualityModal() {
            selectedQuality = currentQuality;
            updateQualitySelection();
            document.getElementById('qualityModal').classList.add('show');
        }

        function closeQualityModal() {
            document.getElementById('qualityModal').classList.remove('show');
        }

        function initQualityModal() {
            const settingsButton = document.getElementById('settingsButton');
            const modal = document.getElementById('qualityModal');
            const applyButton = document.getElementById('applyQuality');
            const cancelButton = document.getElementById('cancelQuality');
            const qualityCards = document.querySelectorAll('.quality-card');

            // Settings button click
            settingsButton.addEventListener('click', openQualityModal);

            // Close modal when clicking backdrop
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    closeQualityModal();
                }
            });

            // Cancel button
            cancelButton.addEventListener('click', closeQualityModal);

            // Quality card selection
            qualityCards.forEach(card => {
                card.addEventListener('click', () => {
                    selectedQuality = card.dataset.quality;
                    updateQualitySelection();
                });
            });

            // Apply button
            applyButton.addEventListener('click', () => {
                applyQualitySettings(selectedQuality);
                saveQualitySettings();
                closeQualityModal();
            });

            // ESC key to close modal
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && modal.classList.contains('show')) {
                    closeQualityModal();
                }
            });
        }

        function init() {
            // Load quality settings first
            loadQualitySettings();
            
            // Initialize level manager
            levelManager = new LevelManager();

            // Scene oluştur
            scene = new THREE.Scene();
            // Fog will be set based on quality settings after loading

            // Kamera oluştur - yılana yakın pozisyon
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 20, 25);
            camera.lookAt(0, 0, 0);

            // Renderer oluştur with quality settings
            const currentSettings = qualitySettings[currentQuality];
            renderer = new THREE.WebGLRenderer({ antialias: currentSettings.antialias });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = currentSettings.shadows;
            renderer.shadowMap.type = currentSettings.shadows ? THREE.PCFSoftShadowMap : THREE.BasicShadowMap;
            renderer.setClearColor(0x1e3c72);
            document.getElementById('gameContainer').appendChild(renderer.domElement);

            // Işıklandırma
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(50, 50, 50);
            directionalLight.castShadow = currentSettings.shadows;
            if (currentSettings.shadows) {
                directionalLight.shadow.mapSize.width = currentSettings.shadowMapSize;
                directionalLight.shadow.mapSize.height = currentSettings.shadowMapSize;
                directionalLight.shadow.camera.near = 0.5;
                directionalLight.shadow.camera.far = 100;
                directionalLight.shadow.camera.left = -50;
                directionalLight.shadow.camera.right = 50;
                directionalLight.shadow.camera.top = 50;
                directionalLight.shadow.camera.bottom = -50;
            }
            scene.add(directionalLight);

            // Nokta ışık - dinamik efekt için
            const pointLight = new THREE.PointLight(0x4ecdc4, 1, 100);
            pointLight.position.set(0, 20, 0);
            scene.add(pointLight);

            // Zemin oluştur
            createGround();

            // Level manager will handle walls and obstacles creation
            walls = [];
            obstacles = [];

            // Yılanı başlat
            initSnake();

            // Yiyecekleri oluştur
            createFood();

            // Özel ödülü oluştur
            createSpecialReward();

            // Apply initial level difficulty and speed
            levelManager.applyLevelSpeed();
            levelManager.applyDifficulty();
            levelManager.updateLevelUI();

            // Event listeners
            document.addEventListener('keydown', handleKeyPress);
            window.addEventListener('resize', onWindowResize);

            // Initialize quality modal
            initQualityModal();

            // Apply initial quality settings
            applyQualitySettings(currentQuality);

            // Mobil dokunmatik kontrol (Swipe)
            const gameContainer = document.getElementById('gameContainer');
            let touchStartX = 0;
            let touchStartY = 0;
            const swipeThreshold = 50; // Minimum kaydırma mesafesi (piksel)

            gameContainer.addEventListener('touchstart', (event) => {
                if (!gameRunning) return; // Oyun çalışmıyorsa dokunmayı yok say
                touchStartX = event.touches[0].clientX;
                touchStartY = event.touches[0].clientY;
            });

            gameContainer.addEventListener('touchend', (event) => {
                if (!gameRunning) return; // Oyun çalışmıyorsa dokunmayı yok say
                const touchEndX = event.changedTouches[0].clientX;
                const touchEndY = event.changedTouches[0].clientY;

                const deltaX = touchEndX - touchStartX;
                const deltaY = touchEndY - touchStartY;

                // Kaydırma eşiğini kontrol et
                if (Math.abs(deltaX) > swipeThreshold || Math.abs(deltaY) > swipeThreshold) {
                    if (Math.abs(deltaX) > Math.abs(deltaY)) {
                        // Yatay kaydırma
                        if (deltaX > 0) {
                            // Sağa kaydırma
                            if (direction !== 'left') nextDirection = 'right';
                        } else {
                            // Sola kaydırma
                            if (direction !== 'right') nextDirection = 'left';
                        }
                    } else {
                        // Dikey kaydırma
                        if (deltaY > 0) {
                            // Aşağı kaydırma
                            if (direction !== 'up') nextDirection = 'down';
                        } else {
                            // Yukarı kaydırma
                            if (direction !== 'down') nextDirection = 'up';
                        }
                    }
                }
                 // Küçük dokunuşlar (tap) için başlangıç ekranını gösterme veya oyunu başlatma (isteğe bağlı - şimdilik kapatıldı)
                // else if (!gameRunning && document.getElementById('startScreen').style.display !== 'none') {
                //     // Başlangıç ekranı görünüyorsa ve eşikten küçük bir dokunuş varsa oyunu başlat
                //     startGame();
                // }
            });

            // Render loop
            animate();
        }

        function createGround() {
            const groundGeometry = new THREE.PlaneGeometry(BOARD_SIZE * GRID_SIZE, BOARD_SIZE * GRID_SIZE);

            // Zemin için özel materyal
            const groundMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x2d5a27,
                transparent: true,
                opacity: 0.8
            });

            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -1;
            ground.receiveShadow = true;
            scene.add(ground);
        }

        function createWalls() {
            // This function is now handled by levelManager.createWallsForLevel()
            // Keeping for backward compatibility but will be empty
        }

        function createObstacles() {
            // This function is now handled by levelManager.createObstaclesForLevel() 
            // Keeping for backward compatibility but will be empty
        }

        function initSnake() {
            snake = [];
            const snakeMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x27ae60,
                shininess: 80
            });

            const headMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x2ecc71,
                shininess: 100
            });

            // Yılan başı
            const headGeometry = new THREE.SphereGeometry(GRID_SIZE / 2, 16, 16);
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.set(0, 1, 0);
            head.castShadow = true;
            snake.push(head);
            scene.add(head);

            // Yılan vücudu
            for(let i = 1; i < 5; i++) {
                const segmentGeometry = new THREE.BoxGeometry(GRID_SIZE * 0.8, GRID_SIZE * 0.8, GRID_SIZE * 0.8);
                const segment = new THREE.Mesh(segmentGeometry, snakeMaterial);
                segment.position.set(-i * GRID_SIZE, 1, 0);
                segment.castShadow = true;
                snake.push(segment);
                scene.add(segment);
            }
        }

        function createFood() {
            // Clear existing foods
            food.forEach(apple => scene.remove(apple));
            specialFoods.forEach(specialFood => scene.remove(specialFood));
            food = [];
            specialFoods = [];
            
            // Create 5 regular apples
            const foodMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x27ae60, // Green apple color
                shininess: 100
            });

            for(let i = 0; i < 5; i++) {
                const foodGeometry = new THREE.SphereGeometry(GRID_SIZE / 3, 12, 12);
                const apple = new THREE.Mesh(foodGeometry, foodMaterial);
                apple.castShadow = true;
                apple.userData = { 
                    originalY: 1,
                    time: Math.random() * Math.PI * 2,
                    type: 'normal',
                    points: 10
                };
                food.push(apple);
                scene.add(apple);
            }

            // Create special foods based on current level
            createSpecialFoods();

            // Position all foods
            positionAllFoods();
        }

        function createSpecialFoods() {
            if (!levelManager) return;
            
            const config = levelManager.getCurrentConfig();
            if (!config.specialFoods) return;

            config.specialFoods.forEach(specialFoodConfig => {
                const foodType = SPECIAL_FOOD_TYPES[specialFoodConfig.type];
                if (!foodType) return;

                for (let i = 0; i < specialFoodConfig.count; i++) {
                    const specialMaterial = new THREE.MeshPhongMaterial({
                        color: foodType.color,
                        shininess: 200,
                        emissive: foodType.emissive
                    });

                    const specialGeometry = new THREE.SphereGeometry((GRID_SIZE / 3) * foodType.scale, 16, 16);
                    const specialApple = new THREE.Mesh(specialGeometry, specialMaterial);
                    
                    specialApple.castShadow = true;
                    specialApple.userData = {
                        originalY: 1,
                        time: Math.random() * Math.PI * 2,
                        type: 'special',
                        foodType: specialFoodConfig.type,
                        points: foodType.points,
                        segments: foodType.segments
                    };
                    
                    specialFoods.push(specialApple);
                    scene.add(specialApple);
                }
            });
        }

        function positionAllFoods() {
            // Position regular foods
            food.forEach(apple => {
                let pos;
                do {
                    pos = getRandomPosition();
                } while (isPositionOccupied(pos.x, pos.z));
                apple.position.set(pos.x, 1, pos.z);
            });

            // Position special foods (try to place them near obstacles for challenge)
            specialFoods.forEach(specialFood => {
                let pos;
                let attempts = 0;
                do {
                    pos = getRandomPosition();
                    attempts++;
                } while (isPositionOccupied(pos.x, pos.z) && attempts < 20);
                
                // If we can't find a clear position, use any position
                if (attempts >= 20) {
                    pos = getRandomPosition();
                }
                
                specialFood.position.set(pos.x, 1, pos.z);
            });
        }

        function createSpecialReward() {
            const rewardMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xf39c12,
                shininess: 200,
                emissive: 0x332200
            });

            const rewardGeometry = new THREE.OctahedronGeometry(GRID_SIZE / 2);
            specialReward = new THREE.Mesh(rewardGeometry, rewardMaterial);
            specialReward.position.set(0, 1, 0);
            specialReward.castShadow = true;
            specialReward.userData = { time: 0 };
            scene.add(specialReward);
        }

        function getRandomPosition() {
            const x = (Math.floor(Math.random() * BOARD_SIZE) - BOARD_SIZE/2) * GRID_SIZE;
            const z = (Math.floor(Math.random() * BOARD_SIZE) - BOARD_SIZE/2) * GRID_SIZE;
            return { x: x, z: z };
        }

        function showSpecialFoodNotification(foodType, points) {
            const foodNames = {
                goldenApple: '🍏 Altın Elma',
                rubyApple: '🍎 Yakut Elma', 
                emeraldFruit: '🟢 Zümrüt Meyve'
            };
            
            const notificationArea = document.getElementById('notificationArea');
            const notification = document.createElement('div');
            notification.className = 'hit-notification';
            notification.style.color = '#f39c12';
            notification.style.fontSize = '40px';
            notification.textContent = `${foodNames[foodType] || 'Özel Meyve'} +${points}`;
            
            notificationArea.appendChild(notification);
            
            setTimeout(() => {
                notification.style.opacity = '0';
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 500);
            }, 1500);
        }

        function isPositionOccupied(x, z) {
            // Yılan kontrolü
            for(let segment of snake) {
                if(Math.abs(segment.position.x - x) < 1.5 && Math.abs(segment.position.z - z) < 1.5) {
                    return true;
                }
            }

            // Regular food collision check
            for(let apple of food) {
                if(Math.abs(apple.position.x - x) < GRID_SIZE && Math.abs(apple.position.z - z) < GRID_SIZE) {
                    return true;
                }
            }
            
            // Special food collision check
            for(let specialFood of specialFoods) {
                if(Math.abs(specialFood.position.x - x) < GRID_SIZE && Math.abs(specialFood.position.z - z) < GRID_SIZE) {
                    return true;
                }
            }
            
            // Special reward collision check
            if(specialReward && Math.abs(specialReward.position.x - x) < GRID_SIZE && Math.abs(specialReward.position.z - z) < GRID_SIZE) {
                return true;
            }

            return false;
        }

        function handleKeyPress(event) {
            if(!gameRunning) return;

            switch(event.key.toLowerCase()) {
                case 'arrowup':
                case 'w':
                    if(direction !== 'down') nextDirection = 'up';
                    break;
                case 'arrowdown':
                case 's':
                    if(direction !== 'up') nextDirection = 'down';
                    break;
                case 'arrowleft':
                case 'a':
                    if(direction !== 'right') nextDirection = 'left';
                    break;
                case 'arrowright':
                case 'd':
                    if(direction !== 'left') nextDirection = 'right';
                    break;
                case ' ':
                    event.preventDefault();
                    if(!gameRunning) startGame();
                    break;
            }
        }

        function triggerHitEffect(type) {
            const hitEdges = document.querySelectorAll('.hit-edge');
            if (hitEdges.length === 0) return;

            hitEdges.forEach(edge => {
                edge.classList.remove('light-hit', 'dark-hit', 'reward-hit'); // Yeni sınıfı da kaldır
            });

            if (type === 'wall') {
                hitEdges.forEach(edge => edge.classList.add('light-hit'));
            } else if (type === 'obstacle') {
                hitEdges.forEach(edge => edge.classList.add('dark-hit'));
            } else if (type === 'reward') { // Yeni durum
                hitEdges.forEach(edge => edge.classList.add('reward-hit'));
            }

            // Kısa bir süre sonra efekti kaldır
            setTimeout(() => {
                hitEdges.forEach(edge => edge.classList.remove('light-hit', 'dark-hit', 'reward-hit')); // Yeni sınıfı da kaldır
            }, 200); // 200ms sonra kaldır
        }

        function updateSnake() {
            direction = nextDirection;

            const head = snake[0];
            let newX = head.position.x;
            let newZ = head.position.z;

            switch(direction) {
                case 'up':
                    newZ -= GRID_SIZE;
                    break;
                case 'down':
                    newZ += GRID_SIZE;
                    break;
                case 'left':
                    newX -= GRID_SIZE;
                    break;
                case 'right':
                    newX += GRID_SIZE;
                    break;
            }

            // Duvardan geçme (wrapping)
            if(newX > BOARD_OFFSET) newX = -BOARD_OFFSET;
            if(newX < -BOARD_OFFSET) newX = BOARD_OFFSET;
            if(newZ > BOARD_OFFSET) newZ = -BOARD_OFFSET;
            if(newZ < -BOARD_OFFSET) newZ = BOARD_OFFSET;

            // Kendine çarpma kontrolü
            if(checkCollision(newX, newZ)) {
                gameOver();
                return;
            }

            // Duvar ve Engel çarpışma kontrolü
            let hitObject = null;

            // Mavi duvar çarpması
            for(let wall of walls) {
                if(Math.abs(wall.position.x - newX) < 1.5 && Math.abs(wall.position.z - newZ) < 1.5) {
                    hitObject = 'wall';
                    break;
                }
            }

            // Kırmızı engel çarpması
            if (hitObject === null) { // Zaten duvara çarpmadıysa engellere bak
                 for(let obstacle of obstacles) {
                    if(Math.abs(obstacle.position.x - newX) < 1.5 && Math.abs(obstacle.position.z - newZ) < 1.5) {
                        hitObject = 'obstacle';
                        break;
                    }
                }
            }

            if (hitObject !== null) {
                shakeScreen(); // Herhangi bir duvara veya engele çarpınca salla
                playSound(200, 0.5, 'sawtooth'); // Duvara veya engele çarpınca oyun bitti sesi
                triggerHitEffect(hitObject); // Ekran kenarı efekti
                
                // Notify level manager of collision
                levelManager.onCollision(hitObject);

                // --- Bildirim Ekleme ---
                const notificationArea = document.getElementById('notificationArea');
                const notification = document.createElement('div');
                notification.classList.add('hit-notification');

                if (hitObject === 'wall') {
                    notification.textContent = '-5';
                    notification.classList.add('wall-hit');
                } else if (hitObject === 'obstacle') {
                    notification.textContent = '-10';
                    notification.classList.add('obstacle-hit');
                }

                notificationArea.appendChild(notification);

                // 2 saniye sonra soluklaşarak kaybolma
                setTimeout(() => {
                    notification.style.opacity = '0'; // Soluklaşmayı başlat
                    setTimeout(() => {
                        if (notification.parentNode) { // Elemanın hala var olduğundan emin ol
                            notificationArea.removeChild(notification); // Soluklaşma sonrası kaldır
                        }
                    }, 500); // CSS geçiş süresi ile eşleşsin
                }, 1500); // 1.5 saniye göründükten sonra soluklaşmaya başla (toplam 2 saniye)
                // --- Bildirim Ekleme Sonu ---

                if (hitObject === 'wall') {
                    // Mavi duvara çarptı
                    const segmentsToRemove = 5;
                    if (snake.length - segmentsToRemove <= 1) { // Baş her zaman kalmalı (minimum uzunluk 1)
                        gameOver();
                        return;
                    } else {
                        for (let i = 0; i < segmentsToRemove; i++) {
                            const removedSegment = snake.pop();
                            if (removedSegment) scene.remove(removedSegment);
                        }
                        updateUI();
                    }
                } else if (hitObject === 'obstacle') {
                    // Kırmızı engele çarptı
                    const segmentsToRemove = 10;
                    if (snake.length <= 10) { // Uzunluk 10 veya altına düşerse öl
                         gameOver();
                         return;
                    } else {
                         // Yılanın boyu 10'dan fazlaysa 10 birim eksilt
                         const currentLength = snake.length;
                         const newLength = Math.max(1, currentLength - segmentsToRemove); // En az 1 segment (baş) kalmalı

                         for (let i = 0; i < currentLength - newLength; i++) {
                            const removedSegment = snake.pop();
                            if (removedSegment) scene.remove(removedSegment);
                         }
                        updateUI();
                         // Kırmızı engele çarpınca sadece engelleri yeniden konumlandır, hızı değiştirme
                        levelManager.regenerateObstaclesOnly();
                    }
                }
                 // Çarpmadan sonra yılanın pozisyonu g��ncellenmeli
                 // Bu kısım alttaki for döngüsünden sonra yapılmalı
            }

            // Yiyecek kontrolü
            checkFoodCollision(newX, newZ);

            // Yılanı hareket ettir (Çarpışma kontrolünden sonra ve oyun hala çalışıyorsa)
            if (gameRunning) {
                 for(let i = snake.length - 1; i > 0; i--) {
                    snake[i].position.copy(snake[i-1].position);
                }

                head.position.set(newX, 1, newZ);

                // Kamera yılanı takip etsin
                const targetCameraX = head.position.x;
                const targetCameraZ = head.position.z + 25;

camera.position.x += (targetCameraX - camera.position.x) * 0.7;
camera.position.z += (targetCameraZ - camera.position.z) * 0.7;
camera.lookAt(head.position.x, 0, head.position.z);
            }

        }

        function checkCollision(x, z) {
            // Kendine çarpma (Sadece kendine çarpma kontrolü burada kaldı)
            for(let i = 2; i < snake.length; i++) {
                if(Math.abs(snake[i].position.x - x) < 1.5 && Math.abs(snake[i].position.z - z) < 1.5) {
                    return true;
                }
            }

            return false;
        }

        function checkFoodCollision(x, z) {
            // Normal food collision check
            for(let i = 0; i < food.length; i++) {
                if(Math.abs(food[i].position.x - x) < 1.5 && Math.abs(food[i].position.z - z) < 1.5) {
                    const baseScore = 10;
                    const bonusScore = Math.floor(baseScore * levelManager.scoreMultiplier);
                    score += bonusScore;
                    
                    // Notify level manager
                    levelManager.onFoodEaten();
                    
                    addSnakeSegment();
                    playSound(800, 0.1);
                    
                    // Regenerate all foods and obstacles
                    createFood();
                    levelManager.regenerateObstaclesOnly();
                    break;
                }
            }

            // Special food collision check
            for(let i = 0; i < specialFoods.length; i++) {
                if(Math.abs(specialFoods[i].position.x - x) < 1.5 && Math.abs(specialFoods[i].position.z - z) < 1.5) {
                    const specialFood = specialFoods[i];
                    const baseScore = specialFood.userData.points;
                    const bonusScore = Math.floor(baseScore * levelManager.scoreMultiplier);
                    score += bonusScore;
                    
                    // Notify level manager
                    levelManager.onFoodEaten();
                    
                    // Add multiple segments based on special food type
                    for (let j = 0; j < specialFood.userData.segments; j++) {
                        addSnakeSegment();
                    }
                    
                    // Play special sound based on food value
                    const pitch = 800 + (baseScore * 4); // Higher pitch for more valuable food
                    playSound(pitch, 0.15, 'triangle');
                    
                    // Show special notification
                    showSpecialFoodNotification(specialFood.userData.foodType, bonusScore);
                    
                    // Regenerate all foods and obstacles
                    createFood();
                    levelManager.regenerateObstaclesOnly();
                    break;
                }
            }

            // Özel ödül kontrolü
            if(Math.abs(specialReward.position.x - x) < 1.5 && Math.abs(specialReward.position.z - z) < 1.5) {
                const baseReward = 100;
                const bonusReward = Math.floor(baseReward * levelManager.scoreMultiplier);
                score += bonusReward;

                // Track treasure collection for achievements
                levelManager.onTreasureCollected();

                // 10 segment ekle
                for(let i = 0; i < 10; i++) {
                    addSnakeSegment();
                }

                playSound(1200, 0.3);
                // shakeScreen(); // Özel ödül yendiğinde ekran sallanması kaldırıldı
                triggerHitEffect('reward'); // Özel ödül yendiğinde sarı kenar efekti

                // Ödülü gizle
                specialReward.position.set(-1000, -1000, -1000);
            }

            // Check level progress after scoring
            levelManager.checkLevelProgress(score);
            updateUI();
        }

        function addSnakeSegment() {
            const segmentMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x27ae60,
                shininess: 80
            });

            const segmentGeometry = new THREE.BoxGeometry(GRID_SIZE * 0.8, GRID_SIZE * 0.8, GRID_SIZE * 0.8);
            const segment = new THREE.Mesh(segmentGeometry, segmentMaterial);

             // Yeni segmenti eklerken, yılanın uzunluğuna göre pozisyon belirle
            if (snake.length > 0) {
                 const lastSegment = snake[snake.length - 1];
                 segment.position.copy(lastSegment.position);
            } else { // Yılanın başı bile yoksa (olmamalı ama defensive coding)
                 segment.position.set(0, 1, 0);
            }
            segment.castShadow = true;

            snake.push(segment);
            scene.add(segment);
        }

        function addRandomObstacle() {
            // Bu fonksiyon artık kullanılmayacak - orijinal oyunda böyle bir mekanik yoktu
        }

        function shakeScreen() {
            const originalPosition = camera.position.clone();
            let shakeCount = 0;
            const shakeIntensity = 0.3; // Sallanma şiddeti (1.0'dan 0.3'e düşürüldü)

            const shakeInterval = setInterval(() => {
                if(shakeCount < 5) { // 10'dan 5'e düşürüldü
                    const shakeX = (Math.random() - 0.5) * shakeIntensity;
                    const shakeY = (Math.random() - 0.5) * shakeIntensity;
                    const shakeZ = (Math.random() - 0.5) * shakeIntensity;

                    camera.position.set(
                        originalPosition.x + shakeX,
                        originalPosition.y + shakeY,
                        originalPosition.z + shakeZ
                    );

                    shakeCount++;
                } else {
                    camera.position.copy(originalPosition);
                    clearInterval(shakeInterval);
                }
            }, 80); // 50ms'den 80ms'ye artırıldı (daha yumuşak)
        }

        function updateAnimations() {
            const speedMultiplier = window.animationSpeedMultiplier || 1.0;
            
            // Regular food animations
            food.forEach(apple => {
                apple.userData.time += 0.1 * speedMultiplier;
                apple.position.y = apple.userData.originalY + Math.sin(apple.userData.time) * 0.2;
                apple.rotation.y += 0.02 * speedMultiplier;
            });

            // Special food animations (more dramatic)
            specialFoods.forEach(specialFood => {
                specialFood.userData.time += 0.08 * speedMultiplier;
                specialFood.position.y = specialFood.userData.originalY + Math.sin(specialFood.userData.time) * 0.3;
                specialFood.rotation.x += 0.03 * speedMultiplier;
                specialFood.rotation.y += 0.04 * speedMultiplier;
                specialFood.rotation.z += 0.02 * speedMultiplier;
            });

            // Special reward animation
            if(specialReward) {
                specialReward.userData.time += 0.05 * speedMultiplier;
                specialReward.rotation.x += 0.02 * speedMultiplier;
                specialReward.rotation.y += 0.03 * speedMultiplier;
                specialReward.position.y = 1 + Math.sin(specialReward.userData.time) * 0.3;
            }
            
            // No more moving obstacles - all obstacles are now static
        }

        function updateUI() {
            document.getElementById('score').textContent = score;
            document.getElementById('length').textContent = snake.length;
            
            // Update quality indicator
            const qualityNames = {
                low: 'Düşük',
                medium: 'Orta',
                high: 'Yüksek'
            };
            document.getElementById('qualityIndicator').textContent = qualityNames[currentQuality] || 'Orta';
            
            // Update level UI
            if (levelManager) {
                levelManager.updateLevelUI();
            }
        }

        function gameOver() {
            gameRunning = false;
            playSound(200, 0.5, 'sawtooth');

            document.getElementById('finalScore').textContent = score;
            document.getElementById('gameOver').style.display = 'block';
        }

        function startGame() {
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('gameOver').style.display = 'none';
            gameRunning = true;

            playSound(600, 0.2);
        }

        function restartGame() {
            // Oyunu sıfırla
            score = 80; // Start with 80 points as requested
            direction = 'right';
            nextDirection = 'right';

            // Eski nesneleri temizle
            snake.forEach(segment => scene.remove(segment));

            // Reset level manager
            if (levelManager) {
                levelManager.resetLevel();
            }

            // Yeniden başlat
            initSnake();
            createFood(); // Elmaları yeniden konumlandır

            // Özel ödülü tekrar göster
            specialReward.position.set(0, 1, 0);

            updateUI();
            startGame();
        }

        function animate() {
            requestAnimationFrame(animate);

            const currentTime = Date.now();

            if(gameRunning && currentTime - lastUpdateTime > gameSpeed) {
                updateSnake();
                lastUpdateTime = currentTime;
            }

            updateAnimations();
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Oyunu başlat
        init();
    </script>
</body>
</html>